---
import 'mapbox-gl/dist/mapbox-gl.css';
import Layout from '@/layouts/Layout.astro';
import { Separator } from '@/components/ui/separator';
import BuildingLayersToggle from '@/components/map/BuildingLayersToggle';
import BuildingInformation from '@/components/map/BuildingInformation';
import SearchBar from '@/components/map/SearchBar';
import ResetViewGroup from '@/components/map/ResetViewGroup';

export function getStaticPaths() {
  return [{ params: { lang: 'en' } }, { params: { lang: 'ko' } }];
}

import { getLangFromUrl, useTranslations } from '@/i18n/utils';
import LanguagePicker from '@/components/map/LanguagePicker.astro';
import ThemePicker from '@/components/ThemePicker';

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
---

<Layout title={t('site.map')}>
  <h1 class="sr-only">
    {t('site.title')}&nbsp;
    {t('site.map')}
  </h1>
  <div id="map" class="h-screen w-screen"></div>
  <BuildingInformation client:load lang={lang} />
  <div class="fixed bottom-0 w-full border-t main-bg px-4 py-2">
    <div class="mb-2 flex items-center justify-between gap-3">
      <div class="shrink-0">
        <img
          class="hidden h-8 dark:block"
          src={lang === 'en'
            ? '/yonsei-logo-dark.png'
            : '/yonsei-logo-dark-ko.png'}
          alt="Yonsei University"
        />
        <img
          class="block h-8 dark:hidden"
          src={lang === 'en'
            ? '/yonsei-logo-light.png'
            : '/yonsei-logo-light-ko.png'}
          alt="Yonsei University"
        />
      </div>
      <SearchBar client:load lang={lang} />
      <div class="flex items-center gap-2">
        <BuildingLayersToggle client:load />
        <Separator orientation="vertical" className="h-6!" />
        <ResetViewGroup lang={lang} client:only="react" />
      </div>
    </div>
    <div
      class="mt-2.5 flex items-center justify-start gap-2 text-xs text-muted-foreground/70"
    >
      <a
        class="transition-colors hover:text-muted-foreground"
        href={`/${lang}/`}
      >
        {t('site.title')}
      </a>
      <Separator orientation="vertical" className="h-3!" />
      <LanguagePicker />
      <Separator orientation="vertical" className="h-3!" />
      <ThemePicker
        className="size-4 bg-transparent hover:bg-transparent! [&>svg]:size-4"
        client:load
      />
    </div>
  </div>
  <script>
    import { buildingLayer, selectedCampus, selectedId } from '@/store';
    import mapboxgl, {
      type Map,
      type DataDrivenPropertyValueSpecification,
      type CustomLayerInterface,
    } from 'mapbox-gl';
    import {
      getAllBuildingIds,
      getAllBuildings,
      getCameraForCampus,
      updateSelectedCampus,
    } from '@/lib/mapApi';
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';

    mapboxgl.accessToken = import.meta.env.PUBLIC_MAPBOX_TOKEN;

    const initialCamera = getCameraForCampus(selectedCampus.get());

    const map = new mapboxgl.Map({
      style: 'mapbox://styles/mapbox/light-v11',
      container: 'map',
      antialias: true,
      attributionControl: false,
      logoPosition: 'top-right',
      minZoom: 14,
      language:
        document.querySelector('html')?.getAttribute('lang') === 'ko'
          ? 'ko'
          : 'en',
      ...initialCamera,
    });

    // Expose map instance to window
    window.map = map;

    map.addControl(new mapboxgl.AttributionControl(), 'top-left');
    map.addControl(new mapboxgl.ScaleControl(), 'bottom-right');
    map.addControl(new mapboxgl.NavigationControl(), 'top-right');

    // Add camera move listener to update selected campus
    map.on('moveend', () => {
      const center = map.getCenter();
      updateSelectedCampus(center.lng, center.lat);
    });

    const allBuildingIds = getAllBuildingIds();
    const allBuildingData = getAllBuildings();

    const modelOrigin: [number, number] = [126.9384, 37.5647];
    const modelAltitude = 0;
    const modelRotate = [Math.PI / 2, 0, 0];

    const modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(
      modelOrigin,
      modelAltitude,
    );

    // transformation parameters to position, rotate and scale the 3D model onto the map
    const modelTransform = {
      translateX: modelAsMercatorCoordinate.x,
      translateY: modelAsMercatorCoordinate.y,
      translateZ: modelAsMercatorCoordinate.z,
      rotateX: modelRotate[0],
      rotateY: modelRotate[1],
      rotateZ: modelRotate[2],
      /* Since the 3D model is in real world meters, a scale transform needs to be
       * applied since the CustomLayerInterface expects units in MercatorCoordinates.
       */
      scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits(),
    };

    const createCustomLayer = (map: Map): CustomLayerInterface => {
      const camera = new THREE.Camera();
      const scene = new THREE.Scene();

      const directionalLight1 = new THREE.DirectionalLight(0xffffff);
      directionalLight1.position.set(0, -70, 100).normalize();
      scene.add(directionalLight1);

      const directionalLight2 = new THREE.DirectionalLight(0xffffff);
      directionalLight2.position.set(0, 70, 100).normalize();
      scene.add(directionalLight2);

      const loader = new GLTFLoader();
      loader.setMeshoptDecoder(MeshoptDecoder); // Required for gltfpack models
      loader.load('/models/gltfpack-rhino.gltf', (gltf) => {
        scene.add(gltf.scene);
      });

      const renderer = new THREE.WebGLRenderer({
        canvas: map.getCanvas(),
        context: map.painter.context.gl,
        antialias: true,
      });

      renderer.autoClear = false;

      return {
        id: 'rhino-simple',
        type: 'custom',
        renderingMode: '3d',
        onAdd: () => {
          // Add logic that runs on layer addition if necessary.
        },
        render: (gl, matrix) => {
          const rotationX = new THREE.Matrix4().makeRotationAxis(
            new THREE.Vector3(1, 0, 0),
            modelTransform.rotateX,
          );
          const rotationY = new THREE.Matrix4().makeRotationAxis(
            new THREE.Vector3(0, 1, 0),
            modelTransform.rotateY,
          );
          const rotationZ = new THREE.Matrix4().makeRotationAxis(
            new THREE.Vector3(0, 0, 1),
            modelTransform.rotateZ,
          );

          const m = new THREE.Matrix4().fromArray(matrix);
          const l = new THREE.Matrix4()
            .makeTranslation(
              modelTransform.translateX,
              modelTransform.translateY,
              modelTransform.translateZ,
            )
            .scale(
              new THREE.Vector3(
                modelTransform.scale,
                -modelTransform.scale,
                modelTransform.scale,
              ),
            )
            .multiply(rotationX)
            .multiply(rotationY)
            .multiply(rotationZ);

          // Set camera projection matrix with extended clipping planes
          const finalMatrix = m.multiply(l);
          camera.projectionMatrix = finalMatrix.clone();
          const near = 0.1;
          const far = 1000000; // Very large far plane to prevent clipping when panning

          // Modify the projection matrix to use custom near/far planes
          // elements[10]: Controls the Z-buffer depth mapping
          // elements[14]: Controls the near/far plane relationship
          camera.projectionMatrix.elements[10] = -(far + near) / (far - near);
          camera.projectionMatrix.elements[14] =
            -(2 * far * near) / (far - near);

          renderer.resetState();
          renderer.render(scene, camera);
          map.triggerRepaint();
        },
      };
    };

    map.on('style.load', () => {
      // Insert the layer beneath any symbol layer.
      const layers = map.getStyle().layers;

      const labelLayerId = layers.find(
        (layer) =>
          layer.type === 'symbol' && layer.layout && layer.layout['text-field'],
      )?.id;

      if (!labelLayerId) {
        return;
      }

      const buildingHeights = Object.fromEntries(
        allBuildingData
          .filter((building) => Boolean(building.height))
          .map((building) => [String(building.id), building.height]),
      );

      const fillExtrusionHeightExpression: DataDrivenPropertyValueSpecification<number> =
        [
          'case',
          // Check if custom height exists in your dictionary
          ['has', ['to-string', ['id']], ['literal', buildingHeights]],
          // If it exists, use the custom height
          ['get', ['to-string', ['id']], ['literal', buildingHeights]],
          // Otherwise, fall back to OSM height data
          ['get', 'height'],
        ];

      const fillExtrusionBaseExpression: DataDrivenPropertyValueSpecification<number> =
        [
          'interpolate',
          ['linear'],
          ['zoom'],
          15,
          0,
          15.05,
          ['get', 'min_height'],
        ];

      // The 'building' layer in the Mapbox Streets
      // vector tileset contains building height data
      // from OpenStreetMap.
      map.addLayer(
        {
          id: 'osm-buildings',
          source: 'composite',
          'source-layer': 'building',
          filter: ['all', ['in', ['id'], ['literal', allBuildingIds]]],
          type: 'fill-extrusion',
          minzoom: 15,
          paint: {
            'fill-extrusion-color': '#aaa',

            // Use an 'interpolate' expression to
            // add a smooth transition effect to
            // the buildings as the user zooms in.
            'fill-extrusion-height': fillExtrusionHeightExpression,
            'fill-extrusion-base': fillExtrusionBaseExpression,
            'fill-extrusion-opacity': [
              'interpolate',
              ['linear'],
              ['zoom'],
              15,
              0, // Fully transparent at zoom 15
              15.05,
              1, // Fully opaque at zoom 15.05
            ],
          },
        },
        labelLayerId,
      );

      map.addLayer(
        {
          id: 'selected-building',
          source: 'composite',
          'source-layer': 'building',
          type: 'fill-extrusion',
          minzoom: 15,
          filter: ['all', ['in', ['id'], '']],
          layout: {
            visibility: 'none',
          },
          paint: {
            'fill-extrusion-color': '#003876',
            'fill-extrusion-height': fillExtrusionHeightExpression,
            'fill-extrusion-base': fillExtrusionBaseExpression,
            'fill-extrusion-opacity': [
              'interpolate',
              ['linear'],
              ['zoom'],
              15,
              0, // Fully transparent at zoom 15
              15.05,
              0.8, // Translucent at zoom 15.05
            ],
          },
        },
        labelLayerId,
      );

      const customLayer = createCustomLayer(map);
      map.addLayer(customLayer, labelLayerId);
      map.setLayoutProperty('rhino-simple', 'visibility', 'none');
    });

    map.on('click', (e) => {
      const features = map.queryRenderedFeatures(e.point, {
        layers: ['osm-buildings'], // make sure this matches your layer name
      });

      if (features.length) {
        const building = features[0];
        const buildingId = building.id;
        selectedId.set(buildingId || '');
      } else {
        selectedId.set('');
        map.setFilter('selected-building', ['==', ['id'], '']);
      }
    });

    const COLLEGE_OF_MEDICINE_IDS: Array<string | number> = [
      1178739301, 1178739302,
    ];

    selectedId.listen((selectedId) => {
      if (selectedId) {
        // If the selected ID is part of the College of Medicine buildings,
        // set the filter to include both buildings.
        if (COLLEGE_OF_MEDICINE_IDS.includes(selectedId)) {
          map.setFilter('selected-building', [
            'all',
            ['in', ['id'], ['literal', COLLEGE_OF_MEDICINE_IDS]],
          ]);
        } else {
          map.setFilter('selected-building', ['==', ['id'], selectedId]);
        }
        if (buildingLayer.get() == 'osm') {
          map.setLayoutProperty('selected-building', 'visibility', 'visible');
        }
      } else {
        map.setFilter('selected-building', ['==', ['id'], '']);
        map.setLayoutProperty('selected-building', 'visibility', 'none');
      }
    });

    buildingLayer.listen((layer) => {
      map.setLayoutProperty('osm-buildings', 'visibility', 'none');
      map.setLayoutProperty('selected-building', 'visibility', 'none');
      map.setLayoutProperty('rhino-simple', 'visibility', 'none');
      if (layer === 'osm') {
        map.setLayoutProperty('selected-building', 'visibility', 'visible');
        map.setLayoutProperty('osm-buildings', 'visibility', 'visible');
      }

      if (layer === 'rhino-simple') {
        map.setLayoutProperty('rhino-simple', 'visibility', 'visible');
      }
    });
  </script>
</Layout>
